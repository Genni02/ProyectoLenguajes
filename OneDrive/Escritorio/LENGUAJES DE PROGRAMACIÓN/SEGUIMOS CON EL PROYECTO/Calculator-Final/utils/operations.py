import math
import re
import sympy as sp
from sympy import symbols, Eq, solve, Matrix, diff, integrate, Rational, simplify, expand, factor
from sympy.parsing.sympy_parser import parse_expr, standard_transformations, implicit_multiplication_application
from fractions import Fraction

class operations:
    def __init__(self):
        """Inicializa la clase de operaciones matem√°ticas"""
        self.allowed_functions = {
            'sin': math.sin, 'cos': math.cos, 'tan': math.tan,
            'asin': math.asin, 'acos': math.acos, 'atan': math.atan,
            'sqrt': math.sqrt, 'log': math.log10, 'ln': math.log,
            'log10': math.log10, 'log2': math.log2, 'exp': math.exp,
            'abs': abs, 'pow': pow, 'pi': math.pi, 'e': math.e,
            'ceil': math.ceil, 'floor': math.floor, 'round': round,
            'factorial': math.factorial, 'degrees': math.degrees, 'radians': math.radians
        }
        
        # S√≠mbolos comunes para √°lgebra simb√≥lica
        self.x, self.y, self.z = sp.symbols('x y z')
        self.t = sp.symbols('t')

        # Diccionario de plantillas/s√≠mbolos especiales
        self.symbol_templates = {
            "x¬≤": "x^2",
            "x^‚ñ°": "x^a",      # 'a' como placeholder
            "log_‚ñ°": "log_a(x)", # logaritmo base a de x
            "‚àö‚ñ°": "sqrt(x)",
            "‚àö[‚ñ°]{‚ñ°}": "root(a, x)", # ra√≠z a-√©sima de x
            "x¬∞": "x^o",       # 'o' como placeholder para grados
            "‚ñ°": "a",          # placeholder gen√©rico
        }
    
    def _preprocess_templates(self, expression):
        """
        Reemplaza los s√≠mbolos y plantillas especiales por su equivalente matem√°tico.
        """
        # Primero, reemplazar todos los s√≠mbolos definidos en self.symbol_templates
        for symbol, replacement in self.symbol_templates.items():
            expression = expression.replace(symbol, replacement)

        # Reemplazar cuadros vac√≠os (‚ñ°, ‚óª, etc.) por 'a' (o el placeholder que prefieras)
        expression = expression.replace("‚ñ°", "a")
        expression = expression.replace("‚óª", "a")

        # Reemplazar plantillas espec√≠ficas con par√©ntesis vac√≠os por variables
        # Ejemplo: x^() -> x^a, log_() -> log_a(x), sqrt() -> sqrt(x), root(,) -> root(a, x)
        import re
        expression = re.sub(r'x\^\(\)', 'x^a', expression)
        expression = re.sub(r'log_\(\)', 'log_a(x)', expression)
        expression = re.sub(r'sqrt\(\)', 'sqrt(x)', expression)
        expression = re.sub(r'root\((,)?\)', 'root(a, x)', expression)
        expression = re.sub(r'root\(([^,]+),([^)]+)\)', r'root(\1, \2)', expression)

        # Reemplazar potencias ^ por **
        import re
        # Solo reemplaza ^ cuando est√° entre s√≠mbolos v√°lidos para evitar errores
        expression = re.sub(r'(\w)\^(\w|\()', r'\1**\2', expression)

        return expression
    
    def process_expression(self, expression):
        """Procesa y eval√∫a una expresi√≥n matem√°tica con pasos espec√≠ficos seg√∫n el tipo"""
        if not expression or not expression.strip():
            raise ValueError("Expresi√≥n vac√≠a")
        
        # S√≠mbolos y plantillas 
        expression = self._preprocess_templates(expression.strip())
        
        # Detectar tipo de operaci√≥n y procesar con pasos espec√≠ficos
        if self._is_equation(expression):
            return self.solve_equation(expression)
        elif self._is_matrix_operation(expression):
            return self.process_matrix(expression)
        elif self._is_derivative(expression):
            return self.calculate_derivative(expression)
        elif self._is_integral(expression):
            return self.calculate_integral(expression)
        elif self._is_fraction(expression):
            return self.process_fraction(expression)
        elif self._contains_variables(expression):
            return self.process_symbolic(expression)
        else:
            # Operaciones b√°sicas (suma, resta, multiplicaci√≥n, divisi√≥n)
            return self._process_basic_operations(expression)
    
    def _is_equation(self, expression):
        """Verifica si es una ecuaci√≥n (contiene =)"""
        return '=' in expression and expression.count('=') == 1
    
    def _is_matrix_operation(self, expression):
        """Verifica si es una operaci√≥n con matrices"""
        return '[' in expression and ']' in expression
    
    def _is_derivative(self, expression):
        """Verifica si es una derivada"""
        return any(keyword in expression.lower() for keyword in ['d/dx', 'derivative', 'diff'])
    
    def _is_integral(self, expression):
        """Verifica si es una integral"""
        return any(keyword in expression.lower() for keyword in ['integral', 'integrate', '‚à´'])
    
    def _is_fraction(self, expression):
        """Verifica si es una fracci√≥n para procesar exactamente"""
        return '/' in expression and not any(func in expression for func in ['sin', 'cos', 'log', 'sqrt'])
    
    def _contains_variables(self, expression):
        """Verifica si contiene variables (x, y, z, t)"""
        return any(var in expression for var in ['x', 'y', 'z', 't']) and '=' not in expression
    
    def _handle_implicit_multiplication(self, expression):
        """Maneja la multiplicaci√≥n impl√≠cita en expresiones"""
        patterns = [
            (r'(\d)([a-zA-Z])', r'\1*\2'),
            (r'(\d)\(', r'\1*('),
            (r'([a-zA-Z])\(', r'\1*('),
            (r'\)([a-zA-Z])', r')*\1'),
            (r'\)(\d)', r')*\1'),
            (r'\)\(', r')*('),
        ]
        
        for pattern, replacement in patterns:
            expression = re.sub(pattern, replacement, expression)
        
        return expression
    
    # ==================== OPERACIONES B√ÅSICAS ====================
    def _process_basic_operations(self, expression):
        """Procesa operaciones b√°sicas: suma, resta, multiplicaci√≥n, divisi√≥n"""
        try:
            steps = []
            steps.append("üî¢ OPERACIONES B√ÅSICAS")
            steps.append("=" * 40)
            steps.append(f"üéØ Expresi√≥n a calcular: {expression}")
            
            # Limpiar expresi√≥n
            cleaned_expression = self._clean_expression(expression)
            if cleaned_expression != expression:
                steps.append(f"üîß Expresi√≥n limpia: {cleaned_expression}")
            
            # Validar
            if not self._validate_expression(cleaned_expression):
                return {
                    'result': "‚ùå Expresi√≥n no v√°lida",
                    'steps': steps + ["‚ùå La expresi√≥n contiene caracteres no permitidos"],
                    'type': 'error'
                }
            
            # Detectar tipo de operaci√≥n b√°sica
            operation_type = self._detect_basic_operation_type(cleaned_expression)
            steps.append(f"üìù Tipo de operaci√≥n: {operation_type}")
            
            # Explicar orden de operaciones
            steps.append("üìö ORDEN DE OPERACIONES (PEMDAS/BODMAS):")
            steps.append("   1Ô∏è‚É£ Par√©ntesis y corchetes")
            steps.append("   2Ô∏è‚É£ Exponentes y ra√≠ces")
            steps.append("   3Ô∏è‚É£ Multiplicaci√≥n y Divisi√≥n (de izquierda a derecha)")
            steps.append("   4Ô∏è‚É£ Suma y Resta (de izquierda a derecha)")
            
            # Mostrar pasos espec√≠ficos seg√∫n la operaci√≥n
            calculation_steps = self._explain_basic_calculation_steps(cleaned_expression)
            steps.extend(calculation_steps)
            
            # Evaluar
            result = self._safe_eval(self._replace_functions_and_constants(cleaned_expression))
            steps.append(f"‚úÖ RESULTADO FINAL: {result}")
            
            return {
                'result': f"üî¢ Resultado: {result}",
                'steps': steps,
                'type': 'basic_operations'
            }
            
        except Exception as e:
            return {
                'result': f"‚ùå Error: {str(e)}",
                'steps': steps + [f"‚ùå Error: {str(e)}"],
                'type': 'error'
            }
    
    def _detect_basic_operation_type(self, expression):
        """Detecta el tipo espec√≠fico de operaci√≥n b√°sica"""
        if '+' in expression and '-' not in expression and '*' not in expression and '/' not in expression:
            return "SUMA"
        elif '-' in expression and '+' not in expression and '*' not in expression and '/' not in expression:
            return "RESTA"
        elif '*' in expression and '+' not in expression and '-' not in expression and '/' not in expression:
            return "MULTIPLICACI√ìN"
        elif '/' in expression and '+' not in expression and '-' not in expression and '*' not in expression:
            return "DIVISI√ìN"
        elif '**' in expression or '^' in expression:
            return "POTENCIACI√ìN"
        else:
            return "OPERACI√ìN MIXTA"
    
    def _explain_basic_calculation_steps(self, expression):
        """Explica los pasos de c√°lculo para operaciones b√°sicas"""
        steps = []
        steps.append("üîç PROCESO DE C√ÅLCULO:")
        
        # Detectar si hay par√©ntesis
        if '(' in expression:
            steps.append("1Ô∏è‚É£ Resolvemos primero lo que est√° entre par√©ntesis")
            # Aqu√≠ podr√≠as agregar l√≥gica m√°s espec√≠fica para mostrar el contenido de par√©ntesis
        
        # Detectar operaciones espec√≠ficas
        if '+' in expression:
            parts = expression.split('+')
            if len(parts) == 2:
                steps.append(f"2Ô∏è‚É£ Sumamos: {parts[0].strip()} + {parts[1].strip()}")
                steps.append(f"   üí° Recordamos: suma significa agregar cantidades")
        
        if '-' in expression and not expression.startswith('-'):
            parts = expression.split('-')
            if len(parts) == 2:
                steps.append(f"2Ô∏è‚É£ Restamos: {parts[0].strip()} - {parts[1].strip()}")
                steps.append(f"   üí° Recordamos: resta significa quitar una cantidad de otra")
        
        if '*' in expression:
            parts = expression.split('*')
            if len(parts) == 2:
                steps.append(f"2Ô∏è‚É£ Multiplicamos: {parts[0].strip()} √ó {parts[1].strip()}")
                steps.append(f"   üí° Recordamos: multiplicar es sumar repetidas veces")
        
        if '/' in expression:
            parts = expression.split('/')
            if len(parts) == 2:
                steps.append(f"2Ô∏è‚É£ Dividimos: {parts[0].strip()} √∑ {parts[1].strip()}")
                steps.append(f"   üí° Recordamos: dividir es repartir en partes iguales")
                # Verificar divisi√≥n por cero
                try:
                    denominator = float(parts[1].strip())
                    if denominator == 0:
                        steps.append("   ‚ö†Ô∏è ATENCI√ìN: Divisi√≥n por cero no est√° definida")
                except:
                    pass
        
        if '**' in expression:
            parts = expression.split('**')
            if len(parts) == 2:
                steps.append(f"2Ô∏è‚É£ Calculamos potencia: {parts[0].strip()}^{parts[1].strip()}")
                steps.append(f"   üí° Recordamos: potencia es multiplicar la base por s√≠ misma")
        
        return steps
    
    # ==================== √ÅLGEBRA SIMB√ìLICA ====================
    def process_symbolic(self, expression):
        """Procesa expresiones de √°lgebra simb√≥lica"""
        try:
            steps = []
            steps.append("üé≠ √ÅLGEBRA SIMB√ìLICA")
            steps.append("=" * 40)
            steps.append(f"üéØ Expresi√≥n simb√≥lica: {expression}")
            
            # Manejar multiplicaci√≥n impl√≠cita
            processed_expr = self._handle_implicit_multiplication(expression)
            if processed_expr != expression:
                steps.append(f"üìù Multiplicaci√≥n expl√≠cita: {processed_expr}")
            
            transformations = standard_transformations + (implicit_multiplication_application,)
            expr = parse_expr(processed_expr, transformations=transformations)
            steps.append(f"‚úÖ Expresi√≥n procesada: {expr}")
            
            result_text = f"üìù Expresi√≥n original: {expr}\n"
            
            # An√°lisis paso a paso
            steps.append("üìö AN√ÅLISIS ALGEBRAICO:")
            
            # 1. Simplificar
            steps.append("1Ô∏è‚É£ SIMPLIFICACI√ìN:")
            simplified = simplify(expr)
            if simplified != expr:
                steps.append(f"   ‚ú® Aplicamos reglas algebraicas: {expr} ‚Üí {simplified}")
                steps.append(f"   üí° Combinamos t√©rminos semejantes y reducimos fracciones")
                result_text += f"‚ú® Simplificada: {simplified}\n"
            else:
                steps.append("   ‚ÑπÔ∏è La expresi√≥n ya est√° en su forma m√°s simple")
            
            # 2. Expandir
            steps.append("2Ô∏è‚É£ EXPANSI√ìN:")
            expanded = expand(expr)
            if expanded != expr:
                steps.append(f"   üìà Desarrollamos productos: {expr} ‚Üí {expanded}")
                steps.append(f"   üí° Aplicamos propiedad distributiva: a(b+c) = ab + ac")
                result_text += f"üìà Expandida: {expanded}\n"
            else:
                steps.append("   ‚ÑπÔ∏è No hay productos que expandir")
            
            # 3. Factorizar
            steps.append("3Ô∏è‚É£ FACTORIZACI√ìN:")
            try:
                factored = factor(expr)
                if factored != expr:
                    steps.append(f"   üîß Factorizamos: {expr} ‚Üí {factored}")
                    steps.append(f"   üí° Encontramos factores comunes o aplicamos f√≥rmulas")
                    result_text += f"üîß Factorizada: {factored}\n"
                else:
                    steps.append("   ‚ÑπÔ∏è No se puede factorizar m√°s")
            except:
                steps.append("   ‚ö†Ô∏è No se pudo factorizar esta expresi√≥n")
            
            # 4. Evaluaci√≥n num√©rica
            steps.append("4Ô∏è‚É£ EVALUACI√ìN NUM√âRICA:")
            try:
                if not expr.has(sp.Symbol):
                    numeric_value = expr.evalf()
                    steps.append(f"   üî¢ Valor num√©rico: {numeric_value}")
                    result_text += f"üî¢ Valor num√©rico: {numeric_value}"
                else:
                    steps.append("   ‚ÑπÔ∏è Contiene variables, necesita valores espec√≠ficos para evaluar")
            except:
                steps.append("   ‚ö†Ô∏è No se pudo evaluar num√©ricamente")
            
            return {
                'result': result_text.strip(),
                'steps': steps,
                'type': 'symbolic'
            }
            
        except Exception as e:
            return {
                'result': f"‚ùå Error: {str(e)}",
                'steps': [f"‚ùå Error en √°lgebra simb√≥lica: {str(e)}"],
                'type': 'error'
            }
    
    # ==================== DERIVADAS E INTEGRALES ====================
    def calculate_derivative(self, expression):
        """Calcula derivadas con pasos detallados de c√°lculo"""
        try:
            steps = []
            steps.append("üìê C√ÅLCULO DE DERIVADAS")
            steps.append("=" * 40)
            steps.append(f"üéØ Expresi√≥n a derivar: {expression}")
            
            # Procesar formato
            func, var = self._parse_derivative_expression(expression)
            steps.append(f"üìù Funci√≥n: f({var}) = {func}")
            steps.append(f"üîç Variable de derivaci√≥n: {var}")
            
            # Explicar concepto
            steps.append("üìö CONCEPTO DE DERIVADA:")
            steps.append("   üí° La derivada mide la raz√≥n de cambio instant√°nea")
            steps.append("   üìä Geom√©tricamente: pendiente de la recta tangente")
            steps.append("   üî¨ F√≠sicamente: velocidad si f(x) es posici√≥n")
            
            # Aplicar reglas paso a paso
            steps.append("üìê REGLAS DE DERIVACI√ìN:")
            derivative_steps = self._explain_derivative_rules_detailed(func)
            steps.extend(derivative_steps)
            
            # Calcular resultado
            derivative = diff(func, var)
            steps.append(f"‚úÖ RESULTADO: f'({var}) = {derivative}")
            
            # Verificar reglas aplicadas
            steps.append("üîç VERIFICACI√ìN:")
            verification_steps = self._verify_derivative_rules(func, derivative)
            steps.extend(verification_steps)
            
            return {
                'result': f"üìê Derivada: {derivative}",
                'steps': steps,
                'type': 'derivative'
            }
            
        except Exception as e:
            return {
                'result': f"‚ùå Error: {str(e)}",
                'steps': [f"‚ùå Error al calcular derivada: {str(e)}"],
                'type': 'error'
            }
    
    def calculate_integral(self, expression):
        """Calcula integrales con pasos detallados"""
        try:
            steps = []
            steps.append("‚à´ C√ÅLCULO DE INTEGRALES")
            steps.append("=" * 40)
            steps.append(f"üéØ Expresi√≥n a integrar: {expression}")
            
            # Procesar formato
            func, var = self._parse_integral_expression(expression)
            steps.append(f"üìù Funci√≥n: f({var}) = {func}")
            steps.append(f"üîç Variable de integraci√≥n: {var}")
            
            # Explicar concepto
            steps.append("üìö CONCEPTO DE INTEGRAL:")
            steps.append("   üí° La integral calcula el √°rea bajo la curva")
            steps.append("   üìä Geom√©tricamente: suma de infinitos rect√°ngulos")
            steps.append("   üî¨ F√≠sicamente: si f(x) es velocidad, integral es distancia")
            
            # Aplicar reglas paso a paso
            steps.append("‚à´ REGLAS DE INTEGRACI√ìN:")
            integral_steps = self._explain_integration_rules_detailed(func)
            steps.extend(integral_steps)
            
            # Calcular resultado
            integral_result = integrate(func, var)
            steps.append(f"‚úÖ RESULTADO: ‚à´f({var})d{var} = {integral_result} + C")
            steps.append("üìù NOTA: Siempre agregamos la constante C en integrales indefinidas")
            
            # Verificar por derivaci√≥n
            steps.append("üîç VERIFICACI√ìN (derivando el resultado):")
            verification = diff(integral_result, var)
            steps.append(f"   d/d{var}[{integral_result}] = {verification}")
            if simplify(verification - func) == 0:
                steps.append("   ‚úÖ Verificaci√≥n exitosa: la derivada coincide con la funci√≥n original")
            
            return {
                'result': f"‚à´ Integral: {integral_result} + C",
                'steps': steps,
                'type': 'integral'
            }
            
        except Exception as e:
            return {
                'result': f"‚ùå Error: {str(e)}",
                'steps': [f"‚ùå Error al calcular integral: {str(e)}"],
                'type': 'error'
            }
    
    def _explain_derivative_rules_detailed(self, func):
        """Explica las reglas de derivaci√≥n con detalle paso a paso"""
        steps = []
        
        # Analizar la funci√≥n y explicar reglas espec√≠ficas
        func_str = str(func)
        
        if func.is_polynomial():
            steps.append("üìê REGLA DE LA POTENCIA:")
            steps.append("   üìñ d/dx(x‚Åø) = n¬∑x‚Åø‚Åª¬π")
            steps.append("   üìñ d/dx(c) = 0 (derivada de constante)")
            steps.append("   üìñ d/dx(cf(x)) = c¬∑f'(x) (factor constante)")
            
            # Mostrar aplicaci√≥n espec√≠fica
            terms = sp.Add.make_args(func)
            for term in terms:
                if term.is_number:
                    steps.append(f"   üîç T√©rmino constante {term}: derivada = 0")
                elif term.has(sp.Symbol):
                    steps.append(f"   üîç T√©rmino {term}: aplicamos regla de potencia")
        
        if 'sin' in func_str:
            steps.append("üìê REGLA TRIGONOM√âTRICA:")
            steps.append("   üìñ d/dx(sin(x)) = cos(x)")
            steps.append("   üí° La derivada del seno es el coseno")
        
        if 'cos' in func_str:
            steps.append("üìê REGLA TRIGONOM√âTRICA:")
            steps.append("   üìñ d/dx(cos(x)) = -sin(x)")
            steps.append("   üí° La derivada del coseno es menos seno")
        
        if 'exp' in func_str or 'e**' in func_str:
            steps.append("üìê REGLA EXPONENCIAL:")
            steps.append("   üìñ d/dx(eÀ£) = eÀ£")
            steps.append("   üí° La funci√≥n exponencial es su propia derivada")
        
        if 'log' in func_str:
            steps.append("üìê REGLA LOGAR√çTMICA:")
            steps.append("   üìñ d/dx(ln(x)) = 1/x")
            steps.append("   üí° La derivada del logaritmo natural")
        
        # Regla de la cadena si es necesario
        if func.has(sp.Function) or any(f in func_str for f in ['sin(', 'cos(', 'exp(', 'log(']):
            steps.append("üîó REGLA DE LA CADENA:")
            steps.append("   üìñ d/dx(f(g(x))) = f'(g(x))¬∑g'(x)")
            steps.append("   üí° Para funciones compuestas")
        
        return steps
    
    def _explain_integration_rules_detailed(self, func):
        """Explica las reglas de integraci√≥n con detalle"""
        steps = []
        func_str = str(func)
        
        if func.is_polynomial():
            steps.append("‚à´ REGLA DE LA POTENCIA:")
            steps.append("   üìñ ‚à´x‚Åø dx = x‚Åø‚Å∫¬π/(n+1) + C")
            steps.append("   üìñ ‚à´c dx = cx + C (integral de constante)")
            steps.append("   üìñ ‚à´cf(x) dx = c‚à´f(x) dx (factor constante sale)")
            
            # Mostrar aplicaci√≥n espec√≠fica
            terms = sp.Add.make_args(func)
            for term in terms:
                if term.is_number:
                    steps.append(f"   üîç T√©rmino constante {term}: integral = {term}x")
                elif term.has(sp.Symbol):
                    steps.append(f"   üîç T√©rmino {term}: aplicamos regla de potencia")
        
        if 'sin' in func_str:
            steps.append("‚à´ REGLA TRIGONOM√âTRICA:")
            steps.append("   üìñ ‚à´sin(x) dx = -cos(x) + C")
            steps.append("   üí° La integral del seno es menos coseno")
        
        if 'cos' in func_str:
            steps.append("‚à´ REGLA TRIGONOM√âTRICA:")
            steps.append("   üìñ ‚à´cos(x) dx = sin(x) + C")
            steps.append("   üí° La integral del coseno es el seno")
        
        if 'exp' in func_str or 'e**' in func_str:
            steps.append("‚à´ REGLA EXPONENCIAL:")
            steps.append("   üìñ ‚à´eÀ£ dx = eÀ£ + C")
            steps.append("   üí° La integral de la exponencial es ella misma")
        
        if func_str == '1/x':
            steps.append("‚à´ REGLA LOGAR√çTMICA:")
            steps.append("   üìñ ‚à´(1/x) dx = ln|x| + C")
            steps.append("   üí° La integral de 1/x es logaritmo natural")
        
        return steps
    
    def _verify_derivative_rules(self, original_func, derivative):
        """Verifica las reglas de derivaci√≥n aplicadas"""
        steps = []
        
        # Verificar t√©rmino por t√©rmino si es suma
        if original_func.is_Add:
            steps.append("   üìä Verificamos t√©rmino por t√©rmino:")
            terms = sp.Add.make_args(original_func)
            der_terms = sp.Add.make_args(derivative)
            for i, term in enumerate(terms):
                if i < len(der_terms):
                    steps.append(f"   ‚úì d/dx({term}) = {der_terms[i]}")
        
        return steps
    
    def _parse_derivative_expression(self, expression):
        """Parsea expresiones de derivada para extraer funci√≥n y variable"""
        if 'd/dx(' in expression:
            start = expression.find('d/dx(') + 5
            end = expression.rfind(')')
            func_str = expression[start:end]
            return parse_expr(func_str), self.x
        elif 'derivative(' in expression:
            start = expression.find('derivative(') + 11
            end = expression.rfind(')')
            args = expression[start:end].split(',')
            if len(args) >= 2:
                return parse_expr(args[0].strip()), symbols(args[1].strip())
            else:
                return parse_expr(args[0].strip()), self.x
        else:
            return parse_expr(expression), self.x
    
    def _parse_integral_expression(self, expression):
        """Parsea expresiones de integral para extraer funci√≥n y variable"""
        if 'integral(' in expression:
            start = expression.find('integral(') + 9
            end = expression.rfind(')')
            args = expression[start:end].split(',')
            if len(args) >= 2:
                return parse_expr(args[0].strip()), symbols(args[1].strip())
            else:
                return parse_expr(args[0].strip()), self.x
        elif 'integrate(' in expression:
            start = expression.find('integrate(') + 10
            end = expression.rfind(')')
            func_str = expression[start:end]
            return parse_expr(func_str), self.x
        else:
            return parse_expr(expression), self.x
    
    # ==================== ECUACIONES ====================
    def solve_equation(self, equation):
        """Resuelve ecuaciones con pasos matem√°ticos detallados"""
        try:
            steps = []
            steps.append("‚öñÔ∏è RESOLUCI√ìN DE ECUACIONES")
            steps.append("=" * 40)
            steps.append(f"üéØ Ecuaci√≥n a resolver: {equation}")
            
            # Procesar multiplicaci√≥n impl√≠cita
            processed_eq = self._handle_implicit_multiplication(equation)
            if processed_eq != equation:
                steps.append(f"üìù Multiplicaci√≥n expl√≠cita: {processed_eq}")
            
            # Separar lados
            left_side, right_side = processed_eq.split('=')
            steps.append(f"üîç Lado izquierdo: {left_side}")
            steps.append(f"üîç Lado derecho: {right_side}")
            
            # Convertir a expresiones simb√≥licas
            transformations = standard_transformations + (implicit_multiplication_application,)
            left_expr = parse_expr(left_side, transformations=transformations)
            right_expr = parse_expr(right_side, transformations=transformations)
            
            eq = Eq(left_expr, right_expr)
            variables = list(eq.free_symbols)
            
            if not variables:
                # Verificaci√≥n de igualdad num√©rica
                left_val = left_expr.evalf()
                right_val = right_expr.evalf()
                steps.append(f"üî¢ Evaluaci√≥n: {left_val} = {right_val}")
                
                result = "‚úÖ La igualdad es verdadera" if left_val == right_val else "‚ùå La igualdad es falsa"
                return {'result': result, 'steps': steps, 'type': 'verification'}
            
            steps.append(f"üéØ Variable a encontrar: {variables[0]}")
            
            # Clasificar y resolver seg√∫n el tipo
            var = variables[0]
            equation_type = self._classify_equation_type(left_expr, var)
            steps.append(f"üìö Tipo de ecuaci√≥n: {equation_type}")
            
            # Resolver paso a paso seg√∫n el tipo
            if equation_type == "LINEAL":
                solution_steps = self._solve_linear_detailed(left_expr, right_expr, var)
            elif equation_type == "CUADR√ÅTICA":
                solution_steps = self._solve_quadratic_detailed(left_expr, right_expr, var)
            else:
                solution_steps = self._solve_general_detailed(left_expr, right_expr, var)
            
            steps.extend(solution_steps)
            
            # Obtener soluci√≥n
            sols = solve(eq, var)
            if sols:
                sol_value = sols[0]
                result_text = f"üéâ SOLUCI√ìN: {var} = {sol_value}"
                if sol_value.is_rational and sol_value.q != 1:
                    result_text += f" = {float(sol_value)}"
                
                # Verificaci√≥n
                steps.append("üîç VERIFICACI√ìN DE LA SOLUCI√ìN:")
                verification = left_expr.subs(var, sol_value)
                steps.append(f"   Sustituyendo {var} = {sol_value} en el lado izquierdo:")
                steps.append(f"   {left_expr.subs(var, sol_value)} = {verification.evalf()}")
                steps.append(f"   Lado derecho: {right_expr.evalf()}")
                steps.append("   ‚úÖ La soluci√≥n es correcta" if verification.evalf() == right_expr.evalf() else "   ‚ùå Error en la soluci√≥n")
                
                return {'result': result_text, 'steps': steps, 'type': 'equation'}
            else:
                return {'result': "‚ùå No hay soluciones", 'steps': steps, 'type': 'equation'}
                
        except Exception as e:
            return {'result': f"‚ùå Error: {str(e)}", 'steps': [f"‚ùå Error: {str(e)}"], 'type': 'error'}
    
    def _classify_equation_type(self, expr, var):
        """Clasifica el tipo de ecuaci√≥n"""
        if expr.is_polynomial(var):
            degree = expr.as_poly(var).degree()
            if degree == 1:
                return "LINEAL"
            elif degree == 2:
                return "CUADR√ÅTICA"
            else:
                return f"POLIN√ìMICA GRADO {degree}"
        else:
            return "TRASCENDENTE"
    
    def _solve_linear_detailed(self, left_expr, right_expr, var):
        """Resuelve ecuaciones lineales con pasos matem√°ticos detallados"""
        steps = []
        steps.append("üìê M√âTODO DE RESOLUCI√ìN LINEAL:")
        steps.append("   üí° Una ecuaci√≥n lineal tiene la forma ax + b = c")
        
        # Obtener coeficientes
        poly = left_expr.as_poly(var)
        a = poly.nth(1) if poly.degree() >= 1 else 0
        b = poly.nth(0)
        c = right_expr
        
        steps.append(f"üìä Identificamos coeficientes: a = {a}, b = {b}, c = {c}")
        steps.append(f"üìù Forma est√°ndar: {a}¬∑{var} + ({b}) = {c}")
        
        steps.append("üîß PASOS DE RESOLUCI√ìN:")
        
        # Paso 1: Aislar t√©rmino con variable
        if b != 0:
            new_right = c - b
            if b > 0:
                steps.append(f"1Ô∏è‚É£ Restamos {b} de ambos lados:")
            else:
                steps.append(f"1Ô∏è‚É£ Sumamos {abs(b)} a ambos lados:")
            steps.append(f"   {a}¬∑{var} + ({b}) - ({b}) = {c} - ({b})")
            steps.append(f"   {a}¬∑{var} = {new_right}")
        else:
            new_right = c
            steps.append(f"1Ô∏è‚É£ No hay t√©rmino independiente que mover")
            steps.append(f"   {a}¬∑{var} = {new_right}")
        
        # Paso 2: Despejar variable
        if a != 1:
            final_result = new_right / a
            steps.append(f"2Ô∏è‚É£ Dividimos ambos lados entre {a}:")
            steps.append(f"   {var} = {new_right} √∑ {a}")
            steps.append(f"   {var} = {final_result}")
        else:
            steps.append(f"2Ô∏è‚É£ El coeficiente es 1, por lo tanto:")
            steps.append(f"   {var} = {new_right}")
        
        return steps
    
    def _solve_quadratic_detailed(self, left_expr, right_expr, var):
        """Resuelve ecuaciones cuadr√°ticas con pasos detallados"""
        steps = []
        steps.append("üìê M√âTODO DE RESOLUCI√ìN CUADR√ÅTICA:")
        steps.append("   üí° Una ecuaci√≥n cuadr√°tica tiene la forma ax¬≤ + bx + c = 0")
        
        # Llevar a forma est√°ndar
        full_expr = left_expr - right_expr
        poly = full_expr.as_poly(var)
        
        a = poly.nth(2) if poly.degree() >= 2 else 0
        b = poly.nth(1) if poly.degree() >= 1 else 0
        c = poly.nth(0)
        
        steps.append(f"üìä Forma est√°ndar: {a}¬∑{var}¬≤ + {b}¬∑{var} + {c} = 0")
        steps.append(f"üìù Coeficientes: a = {a}, b = {b}, c = {c}")
        
        steps.append("üßÆ F√ìRMULA CUADR√ÅTICA:")
        steps.append("   üìñ x = (-b ¬± ‚àö(b¬≤ - 4ac)) / (2a)")
        
        # Calcular discriminante
        discriminant = b**2 - 4*a*c
        steps.append(f"üîç Calculamos discriminante (Œî):")
        steps.append(f"   Œî = b¬≤ - 4ac = ({b})¬≤ - 4({a})({c})")
        steps.append(f"   Œî = {b**2} - {4*a*c} = {discriminant}")
        
        # Analizar discriminante
        if discriminant > 0:
            steps.append("‚úÖ Œî > 0: Dos soluciones reales distintas")
            sqrt_disc = sp.sqrt(discriminant)
            steps.append(f"üî¢ ‚àöŒî = ‚àö{discriminant} = {sqrt_disc}")
            
            x1 = (-b + sqrt_disc) / (2*a)
            x2 = (-b - sqrt_disc) / (2*a)
            
            steps.append("üìä Aplicamos la f√≥rmula:")
            steps.append(f"   x‚ÇÅ = (-{b} + {sqrt_disc}) / (2¬∑{a}) = {x1}")
            steps.append(f"   x‚ÇÇ = (-{b} - {sqrt_disc}) / (2¬∑{a}) = {x2}")
            
        elif discriminant == 0:
            steps.append("‚öñÔ∏è Œî = 0: Una soluci√≥n real doble")
            x = -b / (2*a)
            steps.append(f"üìä x = -b / (2a) = -({b}) / (2¬∑{a}) = {x}")
            
        else:
            steps.append("‚ùå Œî < 0: No hay soluciones reales (soluciones complejas)")
        
        return steps
    
    def _solve_general_detailed(self, left_expr, right_expr, var):
        """Maneja ecuaciones generales"""
        steps = []
        steps.append("üìê ECUACI√ìN GENERAL:")
        steps.append(f"   üéØ Despejamos {var} usando m√©todos algebraicos")
        steps.append(f"   üìù Ecuaci√≥n: {left_expr} = {right_expr}")
        return steps
    
    # ==================== MATRICES Y √ÅLGEBRA LINEAL ====================
    def process_matrix(self, matrix_str):
        """Procesa matrices con √°lgebra lineal detallada"""
        try:
            steps = []
            steps.append("üî¢ MATRICES Y √ÅLGEBRA LINEAL")
            steps.append("=" * 40)
            steps.append(f"üéØ Matriz a procesar: {matrix_str}")
            
            # Convertir a formato Matrix
            if 'Matrix(' not in matrix_str:
                matrix_str = f"Matrix({matrix_str})"
                steps.append(f"üìù Formato SymPy: {matrix_str}")
            
            matrix = eval(matrix_str, {"Matrix": Matrix, "sp": sp, "sqrt": sp.sqrt})
            steps.append(f"‚úÖ Matriz creada: {matrix.rows}√ó{matrix.cols}")
            steps.append(f"üìä Elementos de la matriz:\n{matrix}")
            
            result_text = f"üî¢ Matriz:\n{matrix}\n"
            
            # Propiedades b√°sicas
            steps.append("üìê PROPIEDADES DE LA MATRIZ:")
            steps.append(f"   üìè Dimensiones: {matrix.rows} filas √ó {matrix.cols} columnas")
            steps.append(f"   üîç Tipo: {'Cuadrada' if matrix.rows == matrix.cols else 'Rectangular'}")
            
            if matrix.rows == matrix.cols:
                steps.append("üßÆ C√ÅLCULOS PARA MATRIZ CUADRADA:")
                
                # Determinante
                steps.append("1Ô∏è‚É£ DETERMINANTE:")
                if matrix.rows == 2:
                    steps.append("   üìê Para matriz 2√ó2: det(A) = ad - bc")
                    a, b = matrix[0, 0], matrix[0, 1]
                    c, d = matrix[1, 0], matrix[1, 1]
                    det = a*d - b*c
                    steps.append(f"   üî¢ det = ({a})({d}) - ({b})({c}) = {a*d} - {b*c} = {det}")
                elif matrix.rows == 3:
                    steps.append("   üìê Para matriz 3√ó3: expansi√≥n por cofactores")
                    det = matrix.det()
                    steps.append(f"   üî¢ det = {det}")
                else:
                    det = matrix.det()
                    steps.append(f"   üî¢ det = {det} (calculado por expansi√≥n)")
                
                result_text += f"\nüìä Determinante: {det}"
                
                # An√°lisis del determinante
                steps.append("üìä AN√ÅLISIS DEL DETERMINANTE:")
                if det == 0:
                    steps.append("   ‚ùå det = 0: Matriz singular (no invertible)")
                    steps.append("   üí° Las filas/columnas son linealmente dependientes")
                else:
                    steps.append("   ‚úÖ det ‚â† 0: Matriz no singular (invertible)")
                    steps.append("   üí° Las filas/columnas son linealmente independientes")
                
                # Matriz inversa
                if det != 0:
                    steps.append("2Ô∏è‚É£ MATRIZ INVERSA:")
                    steps.append("   üìê A‚Åª¬π = (1/det(A)) √ó adj(A)")
                    steps.append("   üí° adj(A) es la matriz adjunta (transpuesta de cofactores)")
                    
                    inv = matrix.inv()
                    steps.append("   ‚úÖ Matriz inversa calculada")
                    result_text += f"\nüîÑ Matriz inversa:\n{inv}"
                    
                    # Verificaci√≥n
                    steps.append("üîç VERIFICACI√ìN: A √ó A‚Åª¬π = I")
                    identity_check = matrix * inv
                    steps.append(f"   A √ó A‚Åª¬π = {identity_check}")
                else:
                    steps.append("2Ô∏è‚É£ MATRIZ INVERSA:")
                    steps.append("   ‚ùå No existe matriz inversa (det = 0)")
            
            # Rango
            steps.append("3Ô∏è‚É£ RANGO DE LA MATRIZ:")
            steps.append("   üìê El rango es el n√∫mero m√°ximo de filas/columnas linealmente independientes")
            rank = matrix.rank()
            steps.append(f"   üî¢ rango(A) = {rank}")
            result_text += f"\nüìè Rango: {rank}"
            
            # Interpretaci√≥n del rango
            steps.append("üìä INTERPRETACI√ìN DEL RANGO:")
            if matrix.rows == matrix.cols:
                if rank == matrix.rows:
                    steps.append("   ‚úÖ Rango completo: todas las filas/columnas son independientes")
                else:
                    steps.append(f"   ‚ö†Ô∏è Rango deficiente: solo {rank} de {matrix.rows} filas son independientes")
            
            return {
                'result': result_text,
                'steps': steps,
                'type': 'matrix'
            }
            
        except Exception as e:
            return {
                'result': f"‚ùå Error: {str(e)}",
                'steps': [f"‚ùå Error en matriz: {str(e)}"],
                'type': 'error'
            }
    
    # ==================== FRACCIONES EXACTAS ====================
    def process_fraction(self, expression):
        """Procesa fracciones con aritm√©tica exacta"""
        try:
            steps = []
            steps.append("üî¢ C√ÅLCULO CON FRACCIONES EXACTAS")
            steps.append("=" * 40)
            steps.append(f"üéØ Expresi√≥n con fracciones: {expression}")
            
            expr = parse_expr(expression)
            steps.append(f"üìù Expresi√≥n simb√≥lica: {expr}")
            
            # Detectar operaci√≥n con fracciones
            operation_type = self._detect_fraction_operation_type(expression)
            steps.append(f"üìä Tipo de operaci√≥n: {operation_type}")
            
            # Explicar conceptos
            steps.append("üìö CONCEPTOS DE FRACCIONES:")
            steps.append("   üí° Una fracci√≥n representa una divisi√≥n a/b")
            steps.append("   üìä Numerador: parte que se toma")
            steps.append("   üìä Denominador: partes en que se divide el total")
            
            # Pasos espec√≠ficos seg√∫n operaci√≥n
            if '+' in expression or '-' in expression:
                fraction_steps = self._explain_fraction_addition_subtraction(expression)
                steps.extend(fraction_steps)
            elif '*' in expression:
                fraction_steps = self._explain_fraction_multiplication(expression)
                steps.extend(fraction_steps)
            elif '/' in expression and expression.count('/') > 1:
                fraction_steps = self._explain_fraction_division(expression)
                steps.extend(fraction_steps)
            
            # Simplificaci√≥n
            steps.append("üîß SIMPLIFICACI√ìN:")
            simplified = simplify(expr)
            
            if simplified != expr:
                steps.append(f"   üìê Aplicamos simplificaci√≥n: {expr} ‚Üí {simplified}")
                steps.append("   üí° Buscamos el m√°ximo com√∫n divisor (MCD) del numerador y denominador")
            else:
                steps.append("   ‚ÑπÔ∏è La fracci√≥n ya est√° en su forma m√°s simple")
            
            # Resultado exacto
            if simplified.is_rational:
                fraction = sp.nsimplify(simplified)
                steps.append(f"‚úÖ FRACCI√ìN EXACTA: {fraction}")
                
                # Conversi√≥n a decimal
                decimal_val = float(fraction)
                steps.append(f"üî¢ EQUIVALENTE DECIMAL: {fraction} = {decimal_val}")
                
                # Informaci√≥n adicional
                if hasattr(fraction, 'p') and hasattr(fraction, 'q'):
                    steps.append(f"üìä Numerador: {fraction.p}")
                    steps.append(f"üìä Denominador: {fraction.q}")
                
                return {
                    'result': f"üî¢ Fracci√≥n exacta: {fraction} = {decimal_val}",
                    'steps': steps,
                    'type': 'fraction'
                }
            else:
                return {
                    'result': f"üî¢ Resultado: {simplified}",
                    'steps': steps,
                    'type': 'fraction'
                }
                
        except Exception as e:
            return {
                'result': f"‚ùå Error: {str(e)}",
                'steps': [f"‚ùå Error en fracciones: {str(e)}"],
                'type': 'error'
            }
    
    def _detect_fraction_operation_type(self, expression):
        """Detecta el tipo de operaci√≥n con fracciones"""
        if '+' in expression:
            return "SUMA DE FRACCIONES"
        elif '-' in expression:
            return "RESTA DE FRACCIONES"
        elif '*' in expression:
            return "MULTIPLICACI√ìN DE FRACCIONES"
        elif expression.count('/') > 1:
            return "DIVISI√ìN DE FRACCIONES"
        else:
            return "SIMPLIFICACI√ìN DE FRACCI√ìN"
    
    def _explain_fraction_addition_subtraction(self, expression):
        """Explica suma y resta de fracciones"""
        steps = []
        steps.append("‚ûï SUMA/RESTA DE FRACCIONES:")
        steps.append("   üìê Regla: a/b ¬± c/d = (ad ¬± bc)/(bd)")
        steps.append("   üí° Necesitamos un denominador com√∫n")
        steps.append("üîß PASOS:")
        steps.append("   1Ô∏è‚É£ Encontrar el m√≠nimo com√∫n m√∫ltiplo (MCM) de los denominadores")
        steps.append("   2Ô∏è‚É£ Convertir cada fracci√≥n al denominador com√∫n")
        steps.append("   3Ô∏è‚É£ Sumar/restar los numeradores")
        steps.append("   4Ô∏è‚É£ Simplificar el resultado")
        return steps
    
    def _explain_fraction_multiplication(self, expression):
        """Explica multiplicaci√≥n de fracciones"""
        steps = []
        steps.append("‚úñÔ∏è MULTIPLICACI√ìN DE FRACCIONES:")
        steps.append("   üìê Regla: (a/b) √ó (c/d) = (a√óc)/(b√ód)")
        steps.append("   üí° Multiplicamos numeradores entre s√≠ y denominadores entre s√≠")
        steps.append("üîß PASOS:")
        steps.append("   1Ô∏è‚É£ Multiplicar numeradores: a √ó c")
        steps.append("   2Ô∏è‚É£ Multiplicar denominadores: b √ó d")
        steps.append("   3Ô∏è‚É£ Simplificar si es posible")
        return steps
    
    def _explain_fraction_division(self, expression):
        """Explica divisi√≥n de fracciones"""
        steps = []
        steps.append("‚ûó DIVISI√ìN DE FRACCIONES:")
        steps.append("   üìê Regla: (a/b) √∑ (c/d) = (a/b) √ó (d/c)")
        steps.append("   üí° Dividir es multiplicar por el rec√≠proco")
        steps.append("üîß PASOS:")
        steps.append("   1Ô∏è‚É£ Cambiar divisi√≥n por multiplicaci√≥n")
        steps.append("   2Ô∏è‚É£ Invertir la segunda fracci√≥n (rec√≠proco)")
        steps.append("   3Ô∏è‚É£ Multiplicar como fracciones normales")
        steps.append("   4Ô∏è‚É£ Simplificar el resultado")
        return steps
    
    # ==================== M√âTODOS AUXILIARES ====================
    def _clean_expression(self, expression):
        """Limpia la expresi√≥n"""
        expression = expression.strip()
        expression = expression.replace('√ó', '*')
        expression = expression.replace('√∑', '/')
        expression = expression.replace('^', '**')
        return expression
    
    def _validate_expression(self, expression):
        """Valida que la expresi√≥n sea v√°lida"""
        allowed_pattern = r'^[0-9+\-*/().,\s\w]*$'
        if not re.match(allowed_pattern, expression):
            return False
        return self._check_parentheses_balance(expression)
    
    def _check_parentheses_balance(self, expression):
        """Verifica balance de par√©ntesis"""
        count = 0
        for char in expression:
            if char == '(':
                count += 1
            elif char == ')':
                count -= 1
                if count < 0:
                    return False
        return count == 0
    
    def _replace_functions_and_constants(self, expression):
        """Reemplaza funciones matem√°ticas"""
        expression = expression.replace('pi', str(math.pi))
        expression = expression.replace('e', str(math.e))
        
        function_replacements = {
            'sqrt': 'math.sqrt', 'sin': 'math.sin', 'cos': 'math.cos',
            'tan': 'math.tan', 'log': 'math.log10', 'ln': 'math.log',
            'exp': 'math.exp', 'abs': 'abs'
        }
        
        for func_name, func_replacement in function_replacements.items():
            pattern = r'\b' + func_name + r'\b'
            expression = re.sub(pattern, func_replacement, expression)
        
        return expression
    
    def _safe_eval(self, expression):
        """Eval√∫a expresi√≥n de forma segura"""
        safe_dict = {
            "__builtins__": {},
            "math": math, "abs": abs, "round": round,
            "pow": pow, "max": max, "min": min
        }
        
        try:
            result = eval(expression, safe_dict)
            if isinstance(result, (int, float)):
                if math.isinf(result):
                    raise ValueError("Resultado infinito")
                elif math.isnan(result):
                    raise ValueError("Resultado no v√°lido")
                return result
            else:
                raise ValueError("Resultado no num√©rico")
        except ZeroDivisionError:
            raise ZeroDivisionError("Divisi√≥n por cero")
        except Exception as e:
            raise ValueError(f"Error: {str(e)}")
    
    def is_valid_expression(self, expression):
        """Verifica si es una expresi√≥n matem√°tica v√°lida"""
        if not expression or len(expression) < 1:
            return False
        
        math_functions = ['sin', 'cos', 'tan', 'sqrt', 'log', 'ln', 'pi', 'e', 
                         'derivative', 'integral', 'diff', 'Matrix', 'd/dx']
        variables = ['x', 'y', 'z', 't']
        
        has_numbers = any(c.isdigit() for c in expression)
        has_operators = any(c in '+-*/=' for c in expression)
        has_functions = any(func in expression.lower() for func in math_functions)
        has_variables = any(var in expression for var in variables)
        has_matrices = '[' in expression and ']' in expression
        
        return (has_numbers and (has_operators or has_functions)) or has_variables or has_matrices
    
    def get_operation_info(self, expression):
        """Obtiene informaci√≥n sobre la operaci√≥n"""
        info = {
            'expression': expression,
            'type': 'unknown',
            'complexity': 'simple'
        }
        
        if self._is_equation(expression):
            info['type'] = 'equation'
        elif self._is_matrix_operation(expression):
            info['type'] = 'matrix'
        elif self._is_derivative(expression):
            info['type'] = 'derivative'
        elif self._is_integral(expression):
            info['type'] = 'integral'
        elif self._contains_variables(expression):
            info['type'] = 'symbolic'
        elif self._is_fraction(expression):
            info['type'] = 'fraction'
        else:
            info['type'] = 'basic_operations'
        
        return info